// paraphrasing http://www-cs-students.stanford.edu/~blynn/lambda/kiselyov.html

B a b c = a (b c)
R a b c = b c a
S a b c = a c (b c)

// Let p, q be combinators.
// Challenge: we let d be [eta-expanded](link to eta-expansion wiki page) p m times, and q n times.
// Let m = 3, n = 2.
// d = (\0, 1, 2 ... n (p 2 1 0)) (\0, 1 ... n (q 1 0))
// What is d ?
// Let n |= d denote d eta-expanded n times.
// 3 |= d = \0, 1, 2 (d 2 1 0)
//
// We can restate our problem as follows: 
// We define Π recursively by:
//          (0 |= c) Π (0 |= d) =                                 c d
//      (n + 1 |= c) Π (0 |= d) =              (0 |= R d) Π (n |= c)
//      (0 |= c) Π (m + 1 |= d) =              (0 |= B c) Π (0 |= d)
//  (n + 1 |= c) Π (m + 1 |= d) =   n |= (0 |= S Π n |= c) Π m |= d

// We can mechanically check that d = (n |= c) Π (m |= d) is a solution

Lambda = Var 
// We convert from a lambda calculus term to a debrujin ADT
Debrujin = 

use Peano.*

debrujin = go [] where
    go binds = 

Combinator = {B | R | S | K | I | C}


// [ _ ; _ ]
[ {T: Type 0}; {n: Peano} ] = Array (toPeano n) T
Array n = eta-expand n

Array Z = {unreachable}
Array (S n) = \v -> (ArrayEl.create v)


// How we represent an eta-expansion
_ |= _ : Peano, CLTerm ->
(eta-expansions: Peano) |= (expr: CLTerm)
    = { eta-expansions, expr }

translation Z = 1 |= i
translation (S e) =
    let (n |= d) = translation e

    (n + 1) |= (0 |= K Π n |= d)
translation (λ e) =
    let (n |= d) = translation e
    (match n
        0:   0  |= (K d)
        else:   n-1 |= d 
    )
translation (f @@ x) =
    let (n |= c) = translation f
    let (m |= d) = translation x

    max(n, m) |=
        (n |= c Π m |= d)








// Combinatory Logic term
// @ is apply
CLTerm c = { LinearTerm [c; n] | CLTerm @ Term }




(0 |= c) Π (0 |= d) = apply c d
(n |= c) Π (0 |= d) = (0 |= R d) Π (n-1 |= c)
(0 |= c) Π (m |= d)
    = (0 |= B c) Π (0 |= d)
(n |= c) Π (m |= d)
    let n <@ e = (n-1 |= e)
    let a = n <@(1 <@S Π n <@c)
    a Π m <@d






// Now we complicate it, and make the pi operator fucked up and evil
// The list item at index k is True when the variable with debrujin index k
// is used at least once in the term.

([] |= c) Π ([] |= d) = c @ d
// TODO: should be able to write ([] |= _) Π ([] |= _) = _ @ _
[] |= c Π [] |= d


    (_: [Bool])
Π (
    (_: [Bool]) |= (_: CLExpr))
=

([] |= c)     Π (F, Γ |= d)  = ([] |= c) Π Γ |= d
(F, Γ |= c)  Π [] |= d       = (Γ |= c) Π [] |= d
(F, Γ1 |= c) Π (T, Γ2 |= d) = ([])
(T, Γ1 |= c) Π (F, Γ2 |= d) = ([])
(F, Γ1 |= c) Π (F, Γ2 |= d) = ([])










a,b = (a |= b)

[],c Π [],m               = c@m
[],c Π (True::h, d)       = [],B@c Π h,d
[],c Π (False::h, d)      = [],c   Π h,d
(True::g) Π ([], d)       = 